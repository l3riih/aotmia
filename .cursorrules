# ATOMIA - Agente de IA Educativo AgÃ©ntico
# Reglas principales para desarrollo con Cursor

## ğŸ¯ DESCRIPCIÃ“N DEL PROYECTO
Atomia es un **sistema agÃ©ntico educativo** que implementa aprendizaje personalizado basado en principios pedagÃ³gicos cientÃ­ficos. El sistema combina capacidades de razonamiento avanzado con herramientas educativas especializadas para atomizar contenido, generar preguntas adaptativas, evaluar respuestas, y personalizar rutas de aprendizaje usando agentes de IA con memoria y razonamiento.

## ğŸ¤– ARQUITECTURA AGÃ‰NTICA

### Capacidades AgÃ©nticas Implementadas âœ…
- **Agente Educativo Principal**: ReAct con LangChain para razonamiento educativo
- **Sistema de Memoria Multi-Nivel**: Corto plazo, largo plazo (Redis), semÃ¡ntica (ChromaDB)
- **Herramientas Educativas Especializadas**: BÃºsqueda de Ã¡tomos, seguimiento de progreso, generaciÃ³n de preguntas, evaluaciÃ³n
- **Workflow Plan-Execute-Observe-Reflect**: Implementado con LangGraph
- **Orquestador AgÃ©ntico**: Gestiona el ciclo completo de razonamiento educativo

### Stack TecnolÃ³gico AgÃ©ntico
- **Agentes**: LangChain + LangGraph para workflow de razonamiento
- **LLM Principal**: DeepSeek R1 vÃ­a Azure AI
- **Memoria SemÃ¡ntica**: ChromaDB para bÃºsqueda vectorial
- **Memoria Persistente**: Redis para contexto de usuario
- **Herramientas**: Custom Tools para tareas educativas especÃ­ficas
- **Frontend**: Flutter (multiplataforma: iOS, Android, Web)
- **Backend**: Microservicios Python/FastAPI
- **Bases de Datos**: 
  - PostgreSQL (datos estructurados) - instalaciÃ³n local
  - MongoDB (contenido de Ã¡tomos) - instalaciÃ³n local
  - Neo4j (grafo de conocimiento) - instalaciÃ³n local
- **Queue**: RabbitMQ para procesamiento asÃ­ncrono - instalaciÃ³n local

### ConfiguraciÃ³n AgÃ©ntica
```python
# backend/services/llm_orchestrator/src/config.py
class Config:
    # Azure AI Configuration
AZURE_AI_ENDPOINT = "https://ai-bryanjavierjaramilloc0912ai799661901077.services.ai.azure.com/models"
    AZURE_AI_KEY = os.getenv("AZURE_AI_KEY")
    MODEL_NAME = "deepseek-r1"
    
    # Redis Configuration for Memory
    REDIS_HOST = "localhost"
    REDIS_PORT = 6379
    REDIS_DB = 0
    
    # ChromaDB Configuration for Semantic Memory
    CHROMA_PERSIST_DIR = "./chroma_db"
    CHROMA_COLLECTION = "atomia_memory"
    
    # Agent Configuration
    MAX_ITERATIONS = 10
    MEMORY_WINDOW = 10
    SEMANTIC_SEARCH_LIMIT = 5
```

## Core Pedagogical Principles (Implementation Required)

### 1. Skinner's Teaching Machine
- **Microlearning**: Break content into small, manageable pieces
- **Immediate Feedback**: Provide instant response to every user action
- **Active Participation**: Require user engagement, not passive consumption
- **Progressive Difficulty**: Gradual increase in complexity
- **Individualized Pacing**: Each user advances at their own speed

### 2. Spaced Repetition (SM-2 Algorithm)
- **Ease Factor**: 1.3 to 2.5, adjusted based on response quality
- **Interval Calculation**: interval = previous_interval * ease_factor
- **Quality Scoring**: 0-5 scale for response quality assessment
- **Dynamic Scheduling**: Adjust review timing based on forgetting patterns

### 3. Active Learning Implementation
- **Higher-Order Questions**: Focus on analysis, synthesis, evaluation (Bloom's Taxonomy)
- **Scaffolding**: Provide temporary support that's gradually removed
- **Metacognitive Prompts**: Encourage reflection on learning process
- **Connection Building**: Help users relate new information to prior knowledge

### 4. Intermittent Positive Reinforcement
- **Variable Ratio Schedule**: Unpredictable reward timing for maximum engagement
- **Intrinsic + Extrinsic**: Balance internal satisfaction with external rewards
- **Achievement Recognition**: Celebrate effort and progress, not just correct answers
- **Gamification Elements**: Points, badges, streaks, leaderboards (optional)

## ğŸ“‹ COMPONENTES AGÃ‰NTICOS PRINCIPALES

### 1. Agente Educativo Principal (Implementado âœ…)
- **Arquitectura**: ReAct con LangChain para razonamiento educativo
- **Capacidades**: Planifica, ejecuta herramientas, observa resultados, reflexiona
- **Prompt Especializado**: Incluye principios pedagÃ³gicos y objetivos educativos
- **Herramientas**: Acceso a 4 herramientas educativas especializadas

### 2. Sistema de Memoria Multi-Nivel (Implementado âœ…)
- **Memoria a Corto Plazo**: Buffer de conversaciÃ³n en memoria (Ãºltimas 10 interacciones)
- **Memoria a Largo Plazo**: Persistencia en Redis con TTL de 30 dÃ­as
- **Memoria SemÃ¡ntica**: ChromaDB para bÃºsqueda vectorial de interacciones previas
- **Contexto de Usuario**: Perfil, progreso de aprendizaje, historial

### 3. Herramientas Educativas Especializadas (Implementado âœ…)
- **search_learning_atoms**: Busca Ã¡tomos de aprendizaje relacionados con consultas
- **track_learning_progress**: Rastrea y actualiza progreso de aprendizaje
- **generate_adaptive_questions**: Genera preguntas basadas en principios pedagÃ³gicos
- **evaluate_user_answer**: EvalÃºa respuestas y proporciona retroalimentaciÃ³n

### 4. Orquestador AgÃ©ntico con LangGraph (Implementado âœ…)
- **Workflow Plan-Execute-Observe-Reflect**: Ciclo completo de razonamiento
- **Estados del Agente**: Mensajes, tareas, contexto, herramientas usadas, pasos de razonamiento
- **LÃ³gica Condicional**: Decide cuÃ¡ndo continuar iterando o finalizar
- **Manejo de Errores**: RecuperaciÃ³n automÃ¡tica con lÃ­mites de reintentos

### 5. MÃ³dulo de AtomizaciÃ³n de Contenido
- Descompone material educativo en Ã¡tomos de aprendizaje
- Cada Ã¡tomo: autocontenido, coherente, evaluable
- Establece relaciones y prerrequisitos entre Ã¡tomos
- Usa LLM para anÃ¡lisis semÃ¡ntico profundo

### 6. Motor de EvaluaciÃ³n
- EvalÃºa respuestas cerradas (algoritmos) y abiertas (LLM)
- Detecta conceptos errÃ³neos y brechas de conocimiento
- Genera retroalimentaciÃ³n constructiva personalizada
- Actualiza modelo del estudiante en tiempo real

### 7. Planificador Adaptativo
- Implementa repeticiÃ³n espaciada (FSRS)
- Ajusta dificultad y ritmo dinÃ¡micamente
- Balancea contenido nuevo vs repaso
- Detecta necesidades especiales (frustraciÃ³n, aburrimiento)

### 8. Sistema de Adherencia y GamificaciÃ³n
- Refuerzo positivo intermitente
- Puntos, insignias, niveles, progreso visual
- Notificaciones inteligentes personalizadas
- AnÃ¡lisis de comportamiento para prevenir abandono

## ğŸ”§ REGLAS DE DESARROLLO AGÃ‰NTICO

### Estructura de Proyecto AgÃ©ntico
```
atomia/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ llm_orchestrator/     # âœ… Sistema agÃ©ntico completo
â”‚   â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ agents.py     # Agente educativo ReAct
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ memory.py     # Memoria multi-nivel
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tools.py      # Herramientas educativas
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ orchestrator.py # Workflow LangGraph
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py     # ConfiguraciÃ³n agÃ©ntica
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.py       # API FastAPI
â”‚   â”‚   â”‚   â””â”€â”€ requirements.txt
â”‚   â”‚   â”œâ”€â”€ atomization/          # Servicio de atomizaciÃ³n
â”‚   â”‚   â”œâ”€â”€ evaluation/           # Motor de evaluaciÃ³n
â”‚   â”‚   â”œâ”€â”€ planning/             # Planificador adaptativo
â”‚   â”‚   â”œâ”€â”€ questions/            # Generador de preguntas
â”‚   â”‚   â””â”€â”€ gamification/         # Sistema de adherencia
â”‚   â”œâ”€â”€ shared/
â”‚   â”‚   â”œâ”€â”€ models/              # Modelos de datos compartidos
â”‚   â”‚   â”œâ”€â”€ utils/               # Utilidades comunes
â”‚   â”‚   â””â”€â”€ prompts/             # Templates de prompts
â”‚   â””â”€â”€ api_gateway/             # Gateway principal
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ core/               # LÃ³gica central
â”‚   â”‚   â”œâ”€â”€ features/           # Features por mÃ³dulo
â”‚   â”‚   â”œâ”€â”€ shared/             # Componentes compartidos
â”‚   â”‚   â””â”€â”€ config/             # ConfiguraciÃ³n
â”‚   â””â”€â”€ platforms/              # CÃ³digo especÃ­fico por plataforma
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ scripts/               # Scripts de setup y utilidades
â”‚   â””â”€â”€ configs/               # Archivos de configuraciÃ³n
â””â”€â”€ docs/                      # DocumentaciÃ³n existente
```

### Convenciones de CÃ³digo AgÃ©ntico

#### Python (Agentes y Backend)
```python
# Usar type hints siempre con tipos agÃ©nticos
from typing import List, Dict, Optional, TypedDict
from langchain.tools import BaseTool
from langgraph.graph import StateGraph
from pydantic import BaseModel, Field

# Estado del agente con TypedDict
class AgentState(TypedDict):
    messages: List[Any]
    current_task: str
    user_context: Dict[str, Any]
    tools_used: List[str]
    reasoning_steps: List[str]
    final_answer: str
    error_count: int

# Herramientas educativas con BaseModel
class AtomSearchInput(BaseModel):
    query: str = Field(description="Consulta para buscar Ã¡tomos relacionados")
    difficulty: str = Field(default="all", description="Nivel de dificultad")

class AtomSearchTool(BaseTool):
    name = "search_learning_atoms"
    description = "Busca Ã¡tomos de aprendizaje relacionados"
    args_schema: Type[BaseModel] = AtomSearchInput
    
# Async por defecto para endpoints agÃ©nticos
@app.post("/agent/process")
async def process_educational_task(request: EducationalTaskRequest) -> AgentResponse:
    result = await orchestrator.process_educational_task(request.dict())
    return AgentResponse(**result)

# Manejo de errores agÃ©nticos
class AgenticException(Exception):
    pass
```

#### Flutter (Frontend)
```dart
// Estructura de features agÃ©nticas
lib/features/agent_interaction/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ agent_response.dart
â”‚   â”‚   â””â”€â”€ reasoning_step.dart
â”‚   â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ usecases/
â”‚       â””â”€â”€ process_educational_task.dart
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â””â”€â”€ agent_api_datasource.dart
â”‚   â”œâ”€â”€ models/
â”‚   â””â”€â”€ repositories/
â””â”€â”€ presentation/
    â”œâ”€â”€ pages/
    â”‚   â””â”€â”€ agent_chat_page.dart
    â”œâ”€â”€ widgets/
    â”‚   â”œâ”€â”€ reasoning_steps_widget.dart
    â”‚   â””â”€â”€ tools_used_widget.dart
    â””â”€â”€ bloc/
        â””â”€â”€ agent_interaction_bloc.dart

// Uso de BLoC para estado agÃ©ntico
class AgentInteractionBloc extends Bloc<AgentEvent, AgentState> {
  final ProcessEducationalTaskUseCase processTask;
  final SearchMemoryUseCase searchMemory;
}
```

### IntegraciÃ³n AgÃ©ntica con LLMs

#### Agente Educativo ReAct
```python
class EducationalAgent:
    """
    Agente educativo con capacidades de razonamiento, memoria y herramientas especializadas
    """
    
    def __init__(self, llm, tools, memory_system):
        self.llm = llm
        self.tools = tools
        self.memory = memory_system
        
        # Prompt especializado para educaciÃ³n
        self.prompt = PromptTemplate.from_template("""
        Eres un agente de IA educativo especializado en aprendizaje personalizado.
        
        Tu misiÃ³n es:
        1. Atomizar contenido educativo en unidades mÃ­nimas de aprendizaje
        2. Generar preguntas adaptativas basadas en principios pedagÃ³gicos
        3. Evaluar respuestas y proporcionar retroalimentaciÃ³n constructiva
        4. Personalizar rutas de aprendizaje segÃºn el progreso del estudiante
        
        Principios pedagÃ³gicos que debes seguir:
        - Microaprendizaje (Skinner): Divide en unidades pequeÃ±as con feedback inmediato
        - RepeticiÃ³n espaciada: Programa revisiones basadas en curva de olvido
        - Aprendizaje activo: Genera preguntas que requieren reflexiÃ³n profunda
        - Refuerzo intermitente: VarÃ­a recompensas para mantener motivaciÃ³n
        
        Tienes acceso a las siguientes herramientas:
        {tools}
        
        Usuario: {input}
        Pensamiento: {agent_scratchpad}
        """)
        
        # Crear agente ReAct
        self.agent = create_react_agent(self.llm, self.tools, self.prompt)
```

#### Sistema de Memoria Multi-Nivel
```python
class AgenticMemorySystem:
    """
    Sistema de memoria multi-nivel para el agente educativo:
    1. Memoria a corto plazo: Buffer de conversaciÃ³n
    2. Memoria a largo plazo: Persistencia en Redis
    3. Memoria semÃ¡ntica: BÃºsqueda vectorial con ChromaDB
    """
    
    async def add_interaction(self, user_id: str, query: str, 
                            response: str, tools_used: List = None):
        # Almacenar en los 3 niveles de memoria
        pass
    
    async def search_semantic_memory(self, query: str, limit: int = 5) -> List[Dict]:
        # BÃºsqueda vectorial en ChromaDB
        pass
    
    async def get_user_context(self, user_id: str) -> Dict[str, Any]:
        # Recuperar contexto completo del usuario
    pass
```

#### Workflow Plan-Execute-Observe-Reflect
```python
class AgenticOrchestrator:
    """
    Orquestador agÃ©ntico que implementa el ciclo Plan-Execute-Observe-Reflect
    """
    
    def _build_workflow(self) -> StateGraph:
        workflow = StateGraph(AgentState)

        # Nodos del workflow
        workflow.add_node("plan", self._plan_step)
        workflow.add_node("execute", self._execute_step)
        workflow.add_node("observe", self._observe_step)
        workflow.add_node("reflect", self._reflect_step)
        workflow.add_node("finalize", self._finalize_step)
        
        # LÃ³gica condicional para continuar o finalizar
        workflow.add_conditional_edges(
            "reflect",
            self._should_continue,
            {"continue": "plan", "finish": "finalize"}
        )
        
        return workflow.compile()
```

### API Endpoints AgÃ©nticos

#### Servidor FastAPI con Capacidades AgÃ©nticas
```python
# backend/services/llm_orchestrator/src/main.py
app = FastAPI(title="Atomia - Agente Educativo AgÃ©ntico", version="1.0.0")

@app.post("/agent/process", response_model=AgentResponse)
async def process_educational_task(request: EducationalTaskRequest):
    """Procesa una tarea educativa usando el agente con capacidades de razonamiento"""
    result = await orchestrator.process_educational_task(request.dict())
    return AgentResponse(**result)

@app.post("/agent/memory/search")
async def search_memory(query: str, user_id: Optional[str] = None, limit: int = 5):
    """Busca en la memoria semÃ¡ntica del agente"""
    results = await memory_system.search_semantic_memory(query, limit)
    return {"results": results}

@app.get("/agent/context/{user_id}")
async def get_user_context(user_id: str):
    """Obtiene el contexto completo de un usuario"""
    context = await memory_system.get_user_context(user_id)
    return context
```

### Testing AgÃ©ntico

#### Tests para Sistema AgÃ©ntico
```python
# tests/test_agentic_system.py
class TestAgenticSystem:
    @pytest.mark.asyncio
    async def test_educational_task_processing(self):
        """Test completo del procesamiento de tareas educativas"""
        result = await orchestrator.process_educational_task({
            "query": "Explica el concepto de funciones en matemÃ¡ticas",
            "user_id": "test_user_123"
        })
        
        assert "answer" in result
        assert "reasoning_steps" in result
        assert "tools_used" in result
        assert isinstance(result["iterations"], int)
    
    @pytest.mark.asyncio
    async def test_memory_system_integration(self):
        """Test del sistema de memoria multi-nivel"""
        await memory_system.add_interaction(
            user_id="test_user",
            query="Â¿QuÃ© es una funciÃ³n?",
            response="Una funciÃ³n es una relaciÃ³n...",
            tools_used=["search_learning_atoms"]
        )
        
        results = await memory_system.search_semantic_memory("funciones matemÃ¡ticas")
        assert isinstance(results, list)
    
    @pytest.mark.asyncio
    async def test_workflow_execution(self):
        """Test del workflow completo Plan-Execute-Observe-Reflect"""
        # Test pasos del workflow
        state_after_plan = await orchestrator._plan_step(initial_state)
        assert len(state_after_plan['reasoning_steps']) > 0
        assert "PLAN" in state_after_plan['reasoning_steps'][0]
```

### OptimizaciÃ³n y Performance AgÃ©ntica

#### Estrategias Clave para Agentes
1. **Cache de razonamiento**: Redis para razonamientos similares
2. **Memoria semÃ¡ntica**: ChromaDB para reutilizar conocimiento
3. **Procesamiento asÃ­ncrono**: Workflows agÃ©nticos en background
4. **Herramientas optimizadas**: Cache de resultados de herramientas
5. **LÃ­mites de iteraciÃ³n**: Evitar bucles infinitos de razonamiento

#### Monitoreo AgÃ©ntico
```python
# MÃ©tricas especÃ­ficas para el sistema agÃ©ntico
agent_task_duration = prom.Histogram(
    'agent_task_duration_seconds',
    'DuraciÃ³n de procesamiento de tareas educativas',
    ['task_type', 'user_level']
)

agent_reasoning_steps = prom.Histogram(
    'agent_reasoning_steps_count',
    'NÃºmero de pasos de razonamiento por tarea',
    ['task_type', 'completion_status']
)

agent_tool_usage = prom.Counter(
    'agent_tool_usage_total',
    'Uso de herramientas educativas por el agente',
    ['tool_name', 'success']
)
```

## ğŸš€ FLUJOS DE DESARROLLO AGÃ‰NTICO

### 1. Implementar Nueva Herramienta Educativa
1. Definir input/output schema con Pydantic
2. Crear clase heredando de BaseTool
3. Implementar mÃ©todo _run con lÃ³gica especÃ­fica
4. Agregar a get_educational_tools()
5. Actualizar prompt del agente
6. Escribir tests de integraciÃ³n
7. Documentar uso de la herramienta

### 2. Extender Capacidades de Memoria
1. Identificar nuevo tipo de memoria necesaria
2. Extender AgenticMemorySystem
3. Actualizar mÃ©todos de almacenamiento/recuperaciÃ³n
4. Modificar get_user_context para incluir nueva informaciÃ³n
5. Testear integraciÃ³n con agente
6. Optimizar Ã­ndices de bÃºsqueda

### 3. Mejorar Workflow de Razonamiento
1. Identificar nuevos pasos en el workflow
2. Crear mÃ©todos _new_step en AgenticOrchestrator
3. Actualizar _build_workflow con nuevos nodos
4. Modificar lÃ³gica condicional _should_continue
5. Testear nuevo flujo completo
6. Medir impacto en performance

## ğŸ“ MEJORES PRÃCTICAS AGÃ‰NTICAS

### DiseÃ±o de Prompts AgÃ©nticos
- Incluir principios pedagÃ³gicos en system prompt
- Definir claramente misiÃ³n y objetivos educativos
- Listar herramientas disponibles con descripciones
- Proporcionar formato ReAct consistente
- Incluir contexto de usuario personalizado

### Herramientas Educativas
- Una herramienta = una responsabilidad especÃ­fica
- Input/output schemas claros con Pydantic
- DocumentaciÃ³n descriptiva en description
- Manejo robusto de errores
- Logs para debugging y monitoreo

### Sistema de Memoria
- Separar tipos de memoria por propÃ³sito
- TTLs apropiados para cada nivel
- BÃºsqueda semÃ¡ntica para patrones complejos
- Contexto enriquecido para personalizaciÃ³n
- Limpieza automÃ¡tica de datos antiguos

### Workflow de Razonamiento
- LÃ­mites claros de iteraciones
- Manejo graceful de errores
- Estados inmutables en StateGraph
- LÃ³gica condicional robusta
- Logging detallado de pasos

## ğŸ” DEBUGGING AGÃ‰NTICO

### Logs Estructurados AgÃ©nticos
```python
logger.info("Agent task completed", extra={
    "user_id": user_id,
    "task_type": task_type,
    "reasoning_steps": len(reasoning_steps),
    "tools_used": tools_used,
    "iterations": iterations,
    "duration_ms": duration
})
```

### Trazabilidad de Razonamiento
- Loggear cada paso del workflow
- Incluir request_id en toda la cadena agÃ©ntica
- Guardar prompts y respuestas del agente
- Monitorear uso de herramientas
- Detectar patrones de razonamiento anÃ³malos

## ğŸ“š RECURSOS AGÃ‰NTICOS

### DocumentaciÃ³n Clave AgÃ©ntica
- `/development/llm-integration.md` - GuÃ­a completa de integraciÃ³n agÃ©ntica
- `/backend/services/llm_orchestrator/` - CÃ³digo fuente del sistema agÃ©ntico
- `/docs/prompts/` - Templates de prompts educativos
- `/docs/algoritmos/` - Algoritmos pedagÃ³gicos implementados

### Principios AgÃ©nticos Educativos
1. **Razonamiento Educativo**: Cada decisiÃ³n debe basarse en principios pedagÃ³gicos
2. **Memoria Contextual**: Mantener contexto rico del estudiante para personalizaciÃ³n
3. **Herramientas Especializadas**: Cada herramienta debe servir un propÃ³sito educativo especÃ­fico
4. **Workflow Adaptativo**: El ciclo de razonamiento debe adaptarse al contexto educativo

## âš ï¸ CONSIDERACIONES AGÃ‰NTICAS

### Estado Actual del Sistema AgÃ©ntico âœ…
- **Agente educativo ReAct**: Completamente implementado
- **Memoria multi-nivel**: Redis + ChromaDB funcionando
- **4 herramientas educativas**: Implementadas y probadas
- **Workflow LangGraph**: Plan-Execute-Observe-Reflect operativo
- **API FastAPI**: Endpoints agÃ©nticos disponibles

### PrÃ³ximas Prioridades AgÃ©nticas
1. **Agentes especializados**: AtomizaciÃ³n, evaluaciÃ³n, planificaciÃ³n
2. **Coordinador multi-agente**: Orquestar mÃºltiples agentes
3. **Aprendizaje por refuerzo**: Mejora continua basada en feedback
4. **Herramientas avanzadas**: IntegraciÃ³n con bases de datos especÃ­ficas
5. **Dashboard agÃ©ntico**: VisualizaciÃ³n de razonamiento y memoria

### Anti-patterns AgÃ©nticos a Evitar
- NO crear herramientas sin propÃ³sito educativo claro
- NO permitir bucles infinitos de razonamiento
- NO ignorar el contexto de memoria del usuario
- NO diseÃ±ar prompts sin principios pedagÃ³gicos
- NO omitir logging de pasos de razonamiento
- NO asumir que el agente siempre tendrÃ¡ Ã©xito

## ğŸ¤ COLABORACIÃ“N AGÃ‰NTICA

### Commits AgÃ©nticos
```
feat: Add semantic memory search tool
fix: Correct agent reasoning loop termination
docs: Update agentic architecture documentation
test: Add workflow integration tests
refactor: Extract educational tool interface
agent: Improve planning step with pedagogical principles
```

### Pull Requests AgÃ©nticas
- Describir capacidades agÃ©nticas aÃ±adidas/modificadas
- Incluir tests de workflow completo
- Documentar nuevas herramientas o cambios de memoria
- Screenshots de logs de razonamiento
- MÃ©tricas de performance agÃ©ntica

### Code Review AgÃ©ntico
- Verificar principios pedagÃ³gicos en prompts
- Validar manejo de errores en workflow
- Confirmar logging adecuado de razonamiento
- Revisar esquemas de herramientas educativas
- Testear integraciÃ³n de memoria

**El sistema agÃ©ntico de Atomia representa la prÃ³xima generaciÃ³n de educaciÃ³n personalizada, donde agentes inteligentes razonan, recuerdan y adaptan continuamente para optimizar el aprendizaje de cada estudiante.**

## ğŸ³ INICIO DEL PROYECTO CON DOCKER (ACTUALIZADO)

### **ğŸš€ Inicio Completo del Sistema**

**Prerrequisitos:**
- Docker y Docker Compose instalados
- Git para clonar el repositorio
- Variable de entorno AZURE_AI_KEY configurada

```bash
# 1. Clonar el repositorio
git clone <repository-url>
cd Atomia

# 2. Configurar variable de entorno LLM
export AZURE_AI_KEY="your-azure-ai-key-here"

# 3. Iniciar todo el sistema con un solo comando
docker-compose up -d --build

# 4. Verificar estado de servicios
docker-compose ps

# 5. Ver logs si es necesario
docker-compose logs -f [servicio]
```

### **ğŸ“Š Arquitectura Dockerizada Completa**

```yaml
# docker-compose.yml - Sistema completo containerizado
services:
  # ğŸ—„ï¸ INFRAESTRUCTURA
  postgres:     # Base de datos principal (Puerto 5432)
  mongodb:      # Almacenamiento de Ã¡tomos (Puerto 27017)
  redis:        # Cache y memoria (Puerto 6379)
  neo4j:        # Grafo de conocimiento (Puerto 7474, 7687)
  rabbitmq:     # Cola de mensajes (Puerto 5672, 15672)
  
  # ğŸ”§ SERVICIOS BACKEND
  llm_orchestrator:  # Sistema agÃ©ntico principal (Puerto 8002)
  atomization:       # Procesamiento de contenido (Puerto 8001)
  evaluation:        # Motor de evaluaciÃ³n (Puerto 8003)
  planning:          # Planificador adaptativo (Puerto 8004)
  questions:         # Generador de preguntas (Puerto 8005)
  gamification:      # Sistema de adherencia (Puerto 8006)
  authentication:    # AutenticaciÃ³n y autorizaciÃ³n (Puerto 8007)
  
  # ğŸŒ FRONTEND
  frontend:         # AplicaciÃ³n Flutter Web (Puerto 3000)
```

### **ğŸŒ Enlaces de Acceso**

Una vez iniciado el sistema, puedes acceder a:

| Servicio | URL | DescripciÃ³n |
|----------|-----|-------------|
| **AplicaciÃ³n Principal** | http://localhost:3000 | Frontend Flutter Web |
| **API Documentation** | http://localhost:8002/docs | DocumentaciÃ³n LLM Orchestrator |
| **Neo4j Browser** | http://localhost:7474 | Interfaz grÃ¡fica del grafo |
| **RabbitMQ Management** | http://localhost:15672 | Admin de colas (guest/guest) |

### **ğŸ”§ Comandos de GestiÃ³n**

```bash
# Iniciar todo el sistema
docker-compose up -d

# Parar todo el sistema
docker-compose down

# Reiniciar un servicio especÃ­fico
docker-compose restart [servicio]

# Ver logs de un servicio
docker-compose logs -f [servicio]

# Rebuild y reiniciar
docker-compose up -d --build

# Ver estado de todos los servicios
docker-compose ps

# Acceder a shell de un contenedor
docker-compose exec [servicio] bash
```

### **ğŸ” Troubleshooting**

```bash
# Verificar que todos los servicios estÃ©n corriendo
docker-compose ps

# Ver logs de servicios que fallaron
docker-compose logs [servicio-que-fallo]

# Reiniciar servicios con problemas
docker-compose restart [servicio]

# Limpiar y rebuild completo
docker-compose down
docker system prune -f
docker-compose up -d --build

# Verificar puertos ocupados
ss -tlnp | grep -E "(3000|8001|8002|8003|8004|8005|8006|8007)"
```

### **ğŸ“± Frontend Flutter Dockerizado**

**Dockerfile personalizado para Flutter Web:**
```dockerfile
FROM cirrusci/flutter:stable
RUN flutter config --enable-web
WORKDIR /app
COPY pubspec.yaml pubspec.lock ./
RUN flutter pub get
COPY . .
EXPOSE 3000
CMD ["flutter", "run", "-d", "web-server", "--web-port", "3000", "--web-hostname", "0.0.0.0", "--release"]
```

**Variables de entorno para conectar con backend:**
```yaml
environment:
  LLM_ORCHESTRATOR_URL: http://llm_orchestrator:8002
  ATOMIZATION_URL: http://atomization:8001
  EVALUATION_URL: http://evaluation:8003
  PLANNING_URL: http://planning:8004
  QUESTIONS_URL: http://questions:8005
```

### **âš ï¸ Notas Importantes**

1. **Primera ejecuciÃ³n**: El primer `docker-compose up` puede tardar varios minutos en descargar y construir todas las imÃ¡genes.

2. **Variables de entorno**: AsegÃºrate de tener `AZURE_AI_KEY` configurada para el LLM.

3. **Recursos del sistema**: El sistema completo requiere al menos 4GB de RAM disponible.

4. **Persistencia de datos**: Los volÃºmenes Docker mantienen los datos entre reinicios:
   - `postgres_data`: Datos de PostgreSQL
   - `mongo_data`: Datos de MongoDB  
   - `neo4j_data`: Datos de Neo4j
   - `redis_data`: Datos de Redis
   - `rabbitmq_data`: Datos de RabbitMQ

5. **Hot reload**: Flutter en modo release no tiene hot reload. Para desarrollo, ejecutar Flutter localmente.

### **ğŸ”„ Flujo de Desarrollo**

```bash
# Desarrollo de backend
docker-compose up -d postgres mongodb redis neo4j rabbitmq  # Solo infra
# Ejecutar servicios backend localmente para desarrollo

# Desarrollo de frontend  
docker-compose up -d  # Todo el sistema
cd frontend
flutter run -d web-server --web-port 3001  # Puerto diferente para dev
```

### **ğŸ¯ Estado del Sistema Completo**

- âœ… **Infraestructura**: PostgreSQL, MongoDB, Redis, Neo4j, RabbitMQ
- âœ… **Backend**: 7 microservicios agÃ©nticos completamente dockerizados
- âœ… **Frontend**: Flutter Web dockerizado con hot reload opcional
- âœ… **OrquestaciÃ³n**: docker-compose.yml completo y funcional
- âœ… **ConfiguraciÃ³n**: Variables de entorno y redes automÃ¡ticas
- âœ… **Persistencia**: VolÃºmenes para todos los datos importantes

**Â¡Todo el sistema Atomia ahora se inicia con un solo comando Docker Compose!** ğŸ‰ 