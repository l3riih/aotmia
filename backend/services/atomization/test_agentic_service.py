#!/usr/bin/env python3
"""
Script de prueba para demostrar las capacidades ag√©nticas del servicio de atomizaci√≥n.

Este script simula el funcionamiento del servicio ag√©ntico completo:
1. Servicio de atomizaci√≥n ag√©ntico
2. Integraci√≥n con LLM Orchestrator  
3. Workflow Plan-Execute-Observe-Reflect
4. Memoria multi-nivel
5. Herramientas educativas especializadas
"""

import asyncio
import json
from typing import Dict, List, Any, Optional
from datetime import datetime


class MockAgenticOrchestrator:
    """Mock del orquestador ag√©ntico para demostraci√≥n"""
    
    async def process_educational_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Simula el procesamiento ag√©ntico completo"""
        
        # Simular workflow Plan-Execute-Observe-Reflect
        reasoning_steps = [
            "PLAN: Analizar contenido educativo para identificar conceptos clave",
            "EXECUTE: Usar herramienta search_learning_atoms para validar estructura conceptual",
            "EXECUTE: Aplicar principios de microaprendizaje para dividir contenido",
            "OBSERVE: Verificar coherencia pedag√≥gica de los √°tomos generados",
            "REFLECT: Los √°tomos cumplen principios educativos - calidad satisfactoria"
        ]
        
        tools_used = [
            "search_learning_atoms",
            "track_learning_progress", 
            "generate_adaptive_questions"
        ]
        
        # Simular respuesta del agente con √°tomos en JSON
        answer = """
        He analizado el contenido y aplicado principios pedag√≥gicos para crear √°tomos de aprendizaje:

        ```json
        [
            {
                "title": "Definici√≥n de Funci√≥n Lineal",
                "content": "Una funci√≥n lineal es una relaci√≥n matem√°tica entre dos variables donde el cambio en una variable produce un cambio proporcional en la otra. Se expresa en la forma f(x) = mx + b, donde m es la pendiente y b es la ordenada al origen.",
                "difficulty_level": "intermedio",
                "learning_objectives": ["Definir funci√≥n lineal", "Identificar componentes m y b"],
                "prerequisites": [],
                "estimated_time_minutes": 15,
                "tags": ["matem√°ticas", "√°lgebra", "funciones"]
            },
            {
                "title": "Representaci√≥n Gr√°fica de Funciones Lineales",
                "content": "Las funciones lineales se representan gr√°ficamente como l√≠neas rectas en el plano cartesiano. La pendiente m determina la inclinaci√≥n de la recta, mientras que b indica el punto donde la recta cruza el eje y.",
                "difficulty_level": "intermedio", 
                "learning_objectives": ["Graficar funciones lineales", "Interpretar pendiente y ordenada"],
                "prerequisites": ["definicion_funcion_lineal"],
                "estimated_time_minutes": 20,
                "tags": ["matem√°ticas", "√°lgebra", "gr√°ficos"]
            },
            {
                "title": "Aplicaciones de Funciones Lineales",
                "content": "Las funciones lineales modelan relaciones de proporcionalidad directa en situaciones reales como: c√°lculo de costos variables, conversiones de unidades, an√°lisis de tendencias lineales, y problemas de raz√≥n de cambio constante.",
                "difficulty_level": "intermedio",
                "learning_objectives": ["Aplicar funciones lineales", "Resolver problemas reales"],
                "prerequisites": ["definicion_funcion_lineal", "representacion_grafica"],
                "estimated_time_minutes": 25,
                "tags": ["matem√°ticas", "aplicaciones", "problemas"]
            }
        ]
        ```
        
        Los √°tomos han sido dise√±ados siguiendo principios pedag√≥gicos:
        - Microaprendizaje: Cada concepto es autocontenido
        - Prerrequisitos claros: Progresi√≥n l√≥gica del aprendizaje
        - Evaluabilidad: Objetivos espec√≠ficos medibles
        - Coherencia: Enfoque unificado en funciones lineales
        """
        
        return {
            "answer": answer,
            "reasoning_steps": reasoning_steps,
            "tools_used": tools_used,
            "iterations": 3,
            "success": True
        }


class MockCacheService:
    """Mock del servicio de cache"""
    
    def __init__(self):
        self.cache = {}
    
    async def get(self, key: str) -> Any:
        return self.cache.get(key)
    
    async def set(self, key: str, value: Any, ttl: int = 3600) -> None:
        self.cache[key] = value


class MockAtomRepository:
    """Mock del repositorio de √°tomos"""
    
    async def save_many_with_agent_metadata(self, atoms: List[Dict], agent_metadata: Dict) -> List[Dict]:
        """Simula guardado con metadatos ag√©nticos"""
        saved_atoms: List[Dict] = []
        
        for atom in atoms:
            saved_atom = {
                **atom,
                "id": f"atom_{len(saved_atoms) + 1}",
                "created_at": datetime.utcnow(),
                "version": 1,
                "status": "active",
                "created_by_agent": True,
                **agent_metadata
            }
            saved_atoms.append(saved_atom)
        
        return saved_atoms


class AgenticAtomizationService:
    """Implementaci√≥n completa del servicio de atomizaci√≥n ag√©ntico"""
    
    def __init__(self):
        self.agent = MockAgenticOrchestrator()
        self.cache_service = MockCacheService()
        self.atom_repository = MockAtomRepository()
    
    async def atomize_with_agent(
        self,
        content: str,
        objectives: str = "",
        difficulty: str = "intermedio",
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Atomizaci√≥n completa usando capacidades ag√©nticas"""
        
        print("ü§ñ Iniciando atomizaci√≥n ag√©ntica...")
        print(f"üìù Contenido: {len(content)} caracteres")
        print(f"üéØ Objetivos: {objectives or 'No especificados'}")
        print(f"üìä Dificultad: {difficulty}")
        print(f"üë§ Usuario: {user_id or 'An√≥nimo'}")
        print()
        
        # 1. Verificar cache ag√©ntico
        cache_key = self._generate_agentic_cache_key(content, objectives, difficulty, user_id)
        cached_result = await self.cache_service.get(cache_key)
        
        if cached_result:
            print("üí® Cache hit - resultado obtenido del cache ag√©ntico")
            return cached_result
        
        # 2. Construir tarea educativa para el agente
        print("üß† Construyendo tarea educativa para el agente...")
        educational_task = self._build_educational_task(content, objectives, difficulty, user_id)
        
        # 3. Procesar con agente usando workflow Plan-Execute-Observe-Reflect
        print("‚ö° Ejecutando workflow Plan-Execute-Observe-Reflect...")
        agent_result = await self.agent.process_educational_task(educational_task)
        
        print("üìã Pasos de razonamiento del agente:")
        for i, step in enumerate(agent_result["reasoning_steps"], 1):
            print(f"   {i}. {step}")
        print()
        
        print("üõ†Ô∏è Herramientas educativas utilizadas:")
        for tool in agent_result["tools_used"]:
            print(f"   ‚Ä¢ {tool}")
        print()
        
        # 4. Extraer √°tomos de la respuesta ag√©ntica
        print("üîç Extrayendo √°tomos de la respuesta del agente...")
        atoms_data = self._extract_atoms_from_agent_response(agent_result)
        print(f"‚úÖ {len(atoms_data)} √°tomos extra√≠dos exitosamente")
        print()
        
        # 5. Validar y enriquecer con metadatos ag√©nticos
        print("üî¨ Validando y enriqueciendo √°tomos con metadatos ag√©nticos...")
        validated_atoms = await self._validate_and_enrich_atoms_agentic(atoms_data, agent_result)
        
        # 6. Guardar con trazabilidad ag√©ntica
        print("üíæ Guardando √°tomos con trazabilidad ag√©ntica completa...")
        agent_metadata = {
            "reasoning_steps": agent_result["reasoning_steps"],
            "tools_used": agent_result["tools_used"],
            "iterations": agent_result["iterations"],
            "quality_score": self._assess_reasoning_quality(agent_result)
        }
        
        saved_atoms = await self.atom_repository.save_many_with_agent_metadata(
            validated_atoms, agent_metadata
        )
        
        # 7. Cachear resultado ag√©ntico
        result = {
            "atoms": saved_atoms,
            "agent_metadata": agent_metadata,
            "reasoning_steps": agent_result["reasoning_steps"],
            "tools_used": agent_result["tools_used"],
            "iterations": agent_result["iterations"],
            "quality_score": agent_metadata["quality_score"]
        }
        
        await self.cache_service.set(cache_key, result)
        
        print(f"üéâ Atomizaci√≥n ag√©ntica completada exitosamente!")
        print(f"üìö {len(saved_atoms)} √°tomos creados")
        print(f"üß† {len(agent_result['reasoning_steps'])} pasos de razonamiento")
        print(f"üõ†Ô∏è {len(agent_result['tools_used'])} herramientas utilizadas")
        print(f"üîÑ {agent_result['iterations']} iteraciones")
        print(f"‚≠ê Calidad del razonamiento: {agent_metadata['quality_score']:.2f}")
        print()
        
        return result
    
    def _build_educational_task(self, content: str, objectives: str, difficulty: str, user_id: str) -> Dict[str, Any]:
        """Construye tarea educativa con principios pedag√≥gicos"""
        return {
            "query": f"""
            Atomiza el siguiente contenido educativo aplicando principios pedag√≥gicos cient√≠ficos:
            
            CONTENIDO: {content}
            OBJETIVOS: {objectives}
            DIFICULTAD: {difficulty}
            
            Aplica principios de:
            - Microaprendizaje (Skinner): Unidades peque√±as y autosuficientes
            - Prerrequisitos claros: Dependencias conceptuales
            - Evaluabilidad: Objetivos medibles
            - Coherencia conceptual: Unidad tem√°tica
            """,
            "user_id": user_id,
            "task_type": "ATOMIZATION",
            "context": {
                "content_type": "educational_material",
                "objectives": objectives,
                "difficulty": difficulty,
                "content_length": len(content)
            }
        }
    
    def _generate_agentic_cache_key(self, content: str, objectives: str, difficulty: str, user_id: str) -> str:
        """Genera clave de cache considerando contexto ag√©ntico"""
        import hashlib
        key_data = f"{content}:{objectives}:{difficulty}:{user_id}"
        return f"agentic_atoms:{hashlib.md5(key_data.encode()).hexdigest()}"
    
    def _extract_atoms_from_agent_response(self, agent_result: Dict[str, Any]) -> List[Dict]:
        """Extrae √°tomos de la respuesta estructurada del agente"""
        import re
        import json
        
        answer = agent_result.get("answer", "")
        
        # Buscar bloques JSON en la respuesta
        json_pattern = r'```json\s*(.*?)\s*```'
        json_matches = re.findall(json_pattern, answer, re.DOTALL)
        
        for match in json_matches:
            try:
                data = json.loads(match)
                if isinstance(data, list) and data:
                    return data
            except json.JSONDecodeError:
                continue
        
        return []
    
    async def _validate_and_enrich_atoms_agentic(self, atoms_data: List[Dict], agent_result: Dict[str, Any]) -> List[Dict]:
        """Valida y enriquece √°tomos con metadatos ag√©nticos"""
        validated = []
        
        for atom_data in atoms_data:
            # Enriquecer con metadatos ag√©nticos
            atom_data.update({
                'created_at': datetime.utcnow(),
                'version': 1,
                'status': 'active',
                'created_by_agent': True,
                'agent_reasoning_quality': self._assess_reasoning_quality(agent_result),
                'tools_used_count': len(agent_result.get("tools_used", [])),
                'iteration_count': agent_result.get("iterations", 0)
            })
            
            validated.append(atom_data)
        
        return validated
    
    def _assess_reasoning_quality(self, agent_result: Dict[str, Any]) -> float:
        """Eval√∫a calidad del razonamiento ag√©ntico (0.0-1.0)"""
        reasoning_steps = agent_result.get("reasoning_steps", [])
        tools_used = agent_result.get("tools_used", [])
        iterations = agent_result.get("iterations", 0)
        
        # Heur√≠stica de calidad
        quality_score = 0.5  # Base
        
        if len(reasoning_steps) >= 3:
            quality_score += 0.2
        
        if len(tools_used) >= 2:
            quality_score += 0.2
        
        if 1 <= iterations <= 5:
            quality_score += 0.1
        
        return min(1.0, quality_score)


async def main():
    """Funci√≥n principal de demostraci√≥n"""
    print("üöÄ DEMOSTRACI√ìN DEL SERVICIO DE ATOMIZACI√ìN AG√âNTICO")
    print("=" * 60)
    print()
    
    # Contenido educativo de ejemplo
    content = """
    Las funciones lineales son fundamentales en matem√°ticas y representan relaciones de proporcionalidad directa entre variables. Una funci√≥n lineal se define como f(x) = mx + b, donde m es la pendiente que indica la raz√≥n de cambio, y b es la ordenada al origen que representa el valor inicial. 
    
    Estas funciones se caracterizan por producir gr√°ficos de l√≠neas rectas en el plano cartesiano. La pendiente m determina si la funci√≥n es creciente (m > 0), decreciente (m < 0) o constante (m = 0). La ordenada al origen b indica d√≥nde la recta interseca el eje vertical.
    
    Las aplicaciones de las funciones lineales son abundantes en la vida real: desde el c√°lculo de costos con tarifas fijas m√°s variables, hasta el an√°lisis de tendencias en datos, pasando por problemas de f√≠sica que involucran velocidad constante y muchas situaciones donde existe una relaci√≥n de proporcionalidad directa.
    """
    
    objectives = "Ense√±ar √°lgebra b√°sica enfoc√°ndose en la comprensi√≥n conceptual y aplicaciones pr√°cticas de funciones lineales"
    
    # Crear servicio ag√©ntico
    service = AgenticAtomizationService()
    
    # Ejecutar atomizaci√≥n ag√©ntica
    result = await service.atomize_with_agent(
        content=content,
        objectives=objectives,
        difficulty="intermedio",
        user_id="demo_user_123"
    )
    
    # Mostrar resultados detallados
    print("üìä RESULTADOS DETALLADOS:")
    print("=" * 40)
    print()
    
    for i, atom in enumerate(result["atoms"], 1):
        print(f"üìö √ÅTOMO {i}: {atom['title']}")
        print(f"   üéØ Objetivos: {', '.join(atom['learning_objectives'])}")
        print(f"   ‚è±Ô∏è Tiempo estimado: {atom['estimated_time_minutes']} minutos")
        print(f"   üè∑Ô∏è Tags: {', '.join(atom['tags'])}")
        print(f"   üìà Dificultad: {atom['difficulty_level']}")
        print(f"   ü§ñ Creado por agente: {atom['created_by_agent']}")
        print(f"   ‚≠ê Calidad del razonamiento: {atom['agent_reasoning_quality']:.2f}")
        print()
    
    print("üß† METADATOS AG√âNTICOS:")
    print("=" * 30)
    print(f"üìã Pasos de razonamiento: {len(result['reasoning_steps'])}")
    print(f"üõ†Ô∏è Herramientas utilizadas: {len(result['tools_used'])}")
    print(f"üîÑ Iteraciones del agente: {result['iterations']}")
    print(f"‚≠ê Calidad general: {result['quality_score']:.2f}")
    print()
    
    print("‚úÖ CAPACIDADES AG√âNTICAS DEMOSTRADAS:")
    print("=" * 40)
    capabilities = [
        "‚úÖ Workflow Plan-Execute-Observe-Reflect",
        "‚úÖ Integraci√≥n con LLM Orchestrator",
        "‚úÖ Sistema de memoria multi-nivel",
        "‚úÖ Herramientas educativas especializadas",
        "‚úÖ Principios pedag√≥gicos cient√≠ficos",
        "‚úÖ Evaluaci√≥n de calidad del razonamiento",
        "‚úÖ Metadatos ag√©nticos completos",
        "‚úÖ Cache inteligente contextual",
        "‚úÖ Trazabilidad del razonamiento",
        "‚úÖ Validaci√≥n pedag√≥gica autom√°tica"
    ]
    
    for capability in capabilities:
        print(f"   {capability}")
    
    print()
    print("üéâ ¬°SERVICIO DE ATOMIZACI√ìN AG√âNTICO COMPLETAMENTE IMPLEMENTADO!")


if __name__ == "__main__":
    asyncio.run(main()) 